给定一个双端队列，初始时队列为空。

你要对其进行 q 次操作，每次操作可能是以下三种之一：

L x，从队列的左端插入整数 x。
R x，从队列的右端插入整数 x。
? x，请你计算为了使已经处于队列中的整数 x 位于队列的最左端或最右端，至少需要从最左端或最右端弹出多少个数字。
保证操作 3 一定合法（ ? x 中的 x 一定已经处于队列之中）。

每个数字最多被插入到队列中 1 次（队列中一定不会存在重复数字）。

注意，操作 3 只是询问最少需要弹出多少数字，不是真的要弹出它们，队列中的数字始终不会减少。
<h4>输入格式</h4>
第一行包含整数 q。

接下来 q 行，每行包含一个操作信息，格式如题所述。
<h4>输出格式</h4>
对于每个操作 3，输出一行，一个整数表示结果。
<h4>数据范围</h4>
1≤q≤2×105,1≤x≤2×105。
保证至少包含一个操作 3，
保证操作 1 和 2 不会重复插入数字。
保证操作 3 不会询问队列中不存在的数字。
<h4>输入样例1：</h4>
<pre class="hljs"><code>8
L 1
R 2
R 3
? 2
L 4
? 1
L 5
? 1
</code></pre> 

<h4>输出样例1：</h4>
<pre class="hljs"><code>1
1
2
</code></pre>

<h4>输入样例2：</h4>
<pre class="hljs"><code>10
L 100
R 100000
R 123
L 101
? 123
L 10
R 115
? 100
R 110
? 115
</code></pre>

<h4>输出样例2：</h4>
<pre class="hljs"><code>0
2
1
</code></pre>
                    </div>
                    
                    
### 思路
记录插入元素的相对顺序，想象成在一维坐标轴上往原点两边进行插入，
使用哈希表记录插入位置
求解的时候只需要比较查询元素到两边的距离，取最小值即可

### 代码
```python
n = int(input())
dic = {}
l = 0
r = -1
for i in range(n):
    op, num = input().split()
    num = int(num)
    if op == "L":
        dic[num] = l - 1
        l -= 1
    elif op == "R":
        dic[num] = r + 1
        r += 1
    else:
        cur = dic[num]
        print(min(r - cur, cur - l))
```
### 复杂度分析
- T:O(n)
- S:O(n)
